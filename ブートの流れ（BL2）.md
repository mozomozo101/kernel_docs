# ブートデバイスの選択
**この章は、renesas rza1hに特化した内容。
RZA1Hのマニュアルに書いてることを写しただけ**

## ブートモード

SDRAM、HyperFlashなど、どのデバイスからブートするかは、ブートモードによって決まる。  
rza1hの場合、ブートモードは5つある。
* ブートモード0
  * チップセレクト0によって選択されるメモリ空間からのブート
* ブートモード1
  * チップセレクト1によって選択されるメモリ空間からのブート
* ブートモード3
  * SPIフラッシュからのブート
* ブートモード4
  * SDカードからのブート
* ブートモード5
  * MMCからのブート
  
どのブートモードで起動するかは、専用の端子を設定することで選択できる。

## u-bootの起動
RZA1Hでは、ブートモード3の場合の流れはこんな感じ。

* パワーオンリセット解除後、内蔵ROMの 0xFFFF_0000 に格納されたROMコードが実行される。
* ROMコードは、SPIマルチIOバスコントローラを、外部アドレス空間リードモードに設定する
 * u-bootなどがシリアルフラッシュからリードできるようにするため
* 0x1800_0000（SPI領域の先頭） にジャンプする。
 * ここにu-bootが置かれていれば、それが実行される


# ブートローダの動作
ここの翻訳、まとめ。  
https://www.kernel.org/doc/Documentation/arm/Booting  
http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html  

ARM Linuxにおいて、ブートローダが行う必要のある処理は、次の通り。
* メモリの設定
* カーネルを正しいメモリアドレスにロード
* （オプション）initramfsを正しいアドレスにロード
* コンソールの初期化
* カーネルパラメータのセット
* マシンタイプの取得
* レジスタに適切な値を設定し、カーネルに処理を渡す

## メモリの設定
ブートローダは、カーネルが使うRAMを検知、初期化する。この方法はマシン依存。
ちなみに、こうして初期化したメモリのレイアウト情報（カーネルが使用する領域、initramfsの位置等）は、ATAG_MEMというデータ形式で、カーネルに渡す必要がある。
ATAGについては、後ほど説明。

## カーネルのロード
ビルドされた生バイナリであるImageファイルより、圧縮されたzImageを使うのが一般的。
zImageにはヘッダがあり、次のものが含まれる。  

| Offset | Value | Description |
| ---- | ---- | ---- |
| 0x24 | 0x016F2818 | ARM Linux の zImage であることを表すマジックナンバ |
| 0x28 | start address | zImageのロード位置（先頭） |
| 0x2C | end address | zImageのロード位置（末尾） |

zImageのロード位置はどこでも良いが、習慣的に、RAMの先頭から0x8000（32KB）の位置が使われる。
これは、メモリの先頭あたりに置かれているであろう諸々のデータを壊さないようにするため。

## コンソール初期化
シリアルポートを初期化する。
ここで初期化されたシリアルポートは、カーネル起動後、シリアルドライバが検知し、カーネルが使用できるようになる。
なお、"console="オプションを使えば、カーネル側に明示的にシリアルポートを指定することもできる。

### 補足
u-bootで必要なデバイスの初期化処理としては、ピン設定、UARTコントローラやSDホストコントローラ等のレジスタ設定が考えられる。
renesas rza1 starterkit の場合は、[ここでピン設定してる。](https://github.com/renesas-rz/rza_u-boot-2015.01/blob/4c0392eef0e602768b279d7bd256ae8229476cfc/board/renesas/rskrza1/rskrza1.c#L208)

デバイスのレジスタ設定は、[各デバイスのドライバ](https://github.com/renesas-rz/rza_u-boot-2015.01/tree/2015.01-rskrza1/drivers)がやってるようだ。  

当たり前だけど、U-bootは自分が必要なデバイスを初期化するだけ。
カーネルのことまでは面倒見てない。
カーネルはカーネルで、１からデバイス初期化が必要。

## マシンタイプ
カーネルに対して、どんなマシン上で動いているかを知らせる必要がある。
これを表すマシンIDは、[ARM Linuxのサイト](http://www.arm.linux.org.uk/developer/machines/)に書かれている。
ATAGSを使ったブートの場合、このデータをR1レジスタにマシンIDを書き込む。
DTBイメージを使ったブートの場合は、マシンタイプはdtb経由で渡すため、R1レジスタは0で良い。

## ブートデータのセットアップ
ブートローダはカーネルに対し、ブートに必要なデータを渡す必要がある。
最低限必要なのは、この３つ。
* カーネルが使用するメモリ領域の開始位置
* カーネルが使用するメモリ領域のサイズ
* rootfs（initramfsでもOK）の位置

これらのデータを渡す方法には、ATAGSかDTBイメージの２つがある。
ブートローダは、このどちらかを、RAMの適当な場所に配置し、そのアドレスをR2レジスタに入れる。
カーネルは起動時に、このR2レジスタのポインタが指す内容から、データを取得する。

カーネルは、R2レジスタのポインタが指すデータの内容から、それがATAGSかDTBイメージかを判断するようだ。
マジックナンバとして 0xd00dfeed が検知された場合、DTBイメージと判断されるようだ。
これにより、カーネルはこれらのデータを参照できるようになる。

![atags](https://github.com/mozomozo101/kernel_docs/blob/master/images/IMG_1141.jpg)

### ATAGSを使った方法
ブートローダは、自身がセットアップした内容をATAGSにセットして、カーネルに渡す。

ATAGSは、カーネルの自己展開機能によって上書きされないよう、RAMの先頭から16KBの範囲に配置するのが一般的。
なお、カーネルはブートデータを探す時、デフォルトでRAMの先頭から256byteの位置を見に行くようになっている。


### DTBイメージを使った方法
ブートデータのマジックナンバが 0xd00dfeed の場合、カーネルは、それがDTBイメージであると判断するらしい。
DTBイメージの安全な配置場所は、RAMの先頭から128MBの範囲の直前。

```
$ od -x --endian=big r7s72100.dtb |head
0000000 d00d feed 0000 43a7 0000 0038 0000 404c
0000020 0000 0028 0000 0011 0000 0010 0000 0000
```

## initramfsのロード
initramfsも、カーネルの自己展開機能に上書きされないような場所に置く。
オススメの場所は、dtbイメージの直前。

## カーネルの起動
zImage起動時は、いろいろ満たしておかなきゃいけない条件がある。  
詳しくは、[Documentation/arm/Booting](https://www.kernel.org/doc/Documentation/arm/Booting)を見ること。



# u-bootを使ったカーネルブート
http://fowlrat.hatenablog.com/entry/2014/08/31/011056

[カーネルのロード](#カーネルのロード)に書いたとおり、zImageは、RAMの先頭から0x8000（32KB）の位置に展開する。
ただし、u-boot専用のイメージフォーマットであるuImageには、zImageの前に64byte(0x40)のヘッダが付いている。
zImageを(RAMの先頭+0x8000)に置くため、uImiageのロードアドレスは、(RAMの先頭 + 0x8000 - 0x40)となる。

```
=> usb start
=> fatload usb 0 0x0C007FC0 /uImage
=> bootm 0x0C007FC0
```
![u-boot boot](https://github.com/mozomozo101/tech_memo/blob/master/images/IMG_1142.jpg)

もしかしたら、bootm_decomp_image() あたりで、zImageを

bootmでカーネルをブートさせる部分。
zImageのエントリーポイントを実行してることがわかる。
```
// arch/arm/lib/bootm.c
kernel_entry = (void (*)(int, int, uint))images->ep;
...
kernel_entry(0, machid, r2);
```

