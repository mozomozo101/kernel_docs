https://www.youtube.com/watch?v=DV5S_ZSdK0s

SDカードからカーネルを起動する際の流れについて説明。

# 全体的な流れ
* ROMコード  
ピン設定を元にブートデバイスを特定。1stステージブートローダを探し、SoC内のRAMに展開
* 1stステージブートローダ
  NAND/MMCやDRAMコントローラを初期化。2ndステージブートローダをDRAMに展開。
* 2ndステージブートローダ
  kernelやdtbをRAMに展開し、kernelに処理を渡す
  
https://wiki.tizen.org/images/b/bd/Lecture-1.pdf

# ROMコード

## アーキテクチャ
ROMコードのアーキテクチャは以下のとおり。

* ハイレベルレイヤ  
ROMコードのメインタスクであり、watchdog timer やクロックの設定、ブートルーチンが含まれる。

* ドライバレイヤ  
各デバイスと通信するためのプロトコル実装

* HAL 
実際のペリフェラルを制御するための低レベルなコード

つまり・・・  
ROM Codeにはブートに必要なプログラムとして、メインルーチンの他、FATやらXMODEやらTFTPやらが含まれており、
それらは、ドライバが提供する通信プロトコル（UART、SPI、USBなどなど）を使用する。
それぞれのドライバがIPの操作を行う場合は、HALが提供するAPIを使う。  
・・・ということだと思う。

## ROM Bootloader

### 初期化
プロセッサのリセットが走ると、ROMの先頭に処理が移り、ROMコードが実行される。
* システムの初期化
* スタックのセット
* Watchdog Timerのセット（3分）
* クロックの設定
* SYSBOOTピンの設定を元に、ブートデバイスを特定し、イメージを見つけ、ロードする 
    * 見つかる前にwatchdog timerが切れると、システム全体がリセットされる。
    * ブートデバイブートの方法には、２つあり、これらは、SYSBOOTピンなどの設定によって、SoCに伝えることができる。
    ROMコードは、この設定を元に、ブートデバイスを特定する。
        * メモリブート  
        フラッシュメモリなどの記憶媒体から、初期化コード起動する。cold/warm reset 後に行われる。  
        *  ペリフェラルブート  
        UART、USB、Ethernetなどを使い、実行コードを持ってくる方式。デバイスをフラッシュする場合などに使う。
        

### 1st BLをMMC/SDカードからブート
* MMC/SDのドライバを初期化
* カード内にある1st BLが、rawモードか、ブートファイルかを特定する  
    * rawモード  
    #0か#1024のセクタにあり、その先頭に、Configuration Header（CH）が置かれている必要がある。
    ddコマンドで、1st BL, 2nd BLを配置するのが簡単。
    * FATモード
    FATでフォーマットされたプライマリパーティションのルートディレクトリに置かれたイメージをロード　
    
## 2nd BL
大抵、u-bootが使われる。
Linuxカーネルとデバイスツリーをロードする。
u-bootの設定ファイルは、uEnv.txt。　

## デバイスタイプ
デバイスには２種類ある。
セキュアブートかどうかに関係しており、イメージのフォーマットも変わってくる。

* high secure device(HS)  
認証されてない実行コードは許可しない。

* general-purpose device(GP)  
実行コードに対する認証を行わない


## Public RAM

# 起動の流れ
## ROM Code
TrustZoneによりSecure ROM Code はリセットハンドラを持っている。
そのため、リセット後は、必ず、ROM Code



# 補足
## 1st BLはなぜ必要か？
* ROM codeから、直接u-bootをSOCのSRAMに展開、実行してはいけないのか？  
SOC内部のSRAMは高価で、128kb程度しか無い。
u-bootは多機能で、それに比べてサイズが大きいので、u-bootをDRAMに展開する1stBLが必要。

* ROM Codeが、u-bootを直接RAMに展開すれば良いのではないか？
SOCは、製造の時点では、外部にどんなデバイスが接続されるか知らないから。
DRAMについても当然知らないので、


## HALとデバイスドライバの違い
* HAL  
プロセッサの違いを吸収するためのレイヤ。
レジスタ、タイマ、DMA、割り込みなど、プロセッサごとの機能へのアクセスを抽象化する。
ドライバはHALに処理を依頼し、HALは、プロセッサに応じた処理を行う。
https://sciencepark.co.jp/device_driver/dvdr/report-8/

とはいえ、ここを見ると、ドライバの上にHALを置く場合もあるようだ。
https://stackoverflow.com/questions/13577660/define-hal-above-or-below-driver-layer

