https://www.youtube.com/watch?v=DV5S_ZSdK0s

SDカードからカーネルを起動する際の流れについて説明。

# 全体的な流れ
* ROMコード  
ピン設定を元にブートデバイスを特定。1stステージブートローダを探し、SoC内のRAMに展開
* 1stステージブートローダ
  NAND/MMCやDRAMコントローラを初期化。2ndステージブートローダをDRAMに展開。
* 2ndステージブートローダ
  kernelやdtbをRAMに展開し、kernelに処理を渡す
  
https://wiki.tizen.org/images/b/bd/Lecture-1.pdf

# ROMコード

## アーキテクチャ
ROMコードのアーキテクチャは以下のとおり。

* ハイレベルレイヤ  
ROMコードのメインタスクであり、watchdog timer やクロックの設定、ブートルーチンが含まれる。

* ドライバレイヤ  
各デバイスと通信するためのプロトコル実装

* HAL 
実際のペリフェラルを制御するための低レベルなコード

つまり・・・  
ROM Codeにはブートに必要なプログラムとして、メインルーチンの他、FATやらXMODEやらTFTPやらが含まれており、
それらは、ドライバが提供する通信プロトコル（UART、SPI、USBなどなど）を使用する。
それぞれのドライバがIPの操作を行う場合は、HALが提供するAPIを使う。  
・・・ということだと思う。

## ROM Bootloader

### 初期化
プロセッサのリセットが走ると、ROMの先頭に処理が移り、ROMコードが実行される。
* システムの初期化
* スタックのセット
* Watchdog Timerのセット（3分）
* クロックの設定
* SYSBOOTピンの設定を元に、ブートデバイスを特定し、イメージを見つけ、ロードする 

ブートデバイブートの方法には、２つある。
* メモリブート  
フラッシュメモリなどの記憶媒体から、初期化コード起動する。cold/warm reset 後に行われる。  
*  ペリフェラルブート  
UART、USB、Ethernetなどを使い、実行コードを持ってくる方式。デバイスをフラッシュする場合などに使う。

これらは、SYSBOOTピンなどの設定によって、SoCに伝えることができる。
ROMコードは、この設定を元に、ブートデバイスを特定する。

### MMC/SDカードからのブート
* MMC/SDのドライバを初期化
* カード内にある1st BLが、rawモードか、ブートファイルかを特定する  
    * rawモード  
    #0か#1024のセクタにあり、その先頭に、Configuration Header（CH）が置かれている必要がある。
    ddコマンドでブートローダを書き込んだりするのは、こっちの方法に相当する。
    * FATモード
    FATでフォーマットされたプライマリパーティションのルートディレクトリに置かれたイメージをロード　

## デバイスタイプ
デバイスには２種類ある。
セキュアブートかどうかに関係しており、イメージのフォーマットも変わってくる。

* high secure device(HS)  
認証されてない実行コードは許可しない。

* general-purpose device(GP)  
実行コードに対する認証を行わない


## Public RAM

# 起動の流れ
## ROM Code
TrustZoneによりSecure ROM Code はリセットハンドラを持っている。
そのため、リセット後は、必ず、ROM Code



# 補足
## HALとデバイスドライバの違い
* HAL  
プロセッサの違いを吸収するためのレイヤ。
レジスタ、タイマ、DMA、割り込みなど、プロセッサごとの機能へのアクセスを抽象化する。
ドライバはHALに処理を依頼し、HALは、プロセッサに応じた処理を行う。
https://sciencepark.co.jp/device_driver/dvdr/report-8/

とはいえ、ここを見ると、ドライバの上にHALを置く場合もあるようだ。
https://stackoverflow.com/questions/13577660/define-hal-above-or-below-driver-layer

