https://www.youtube.com/watch?v=DV5S_ZSdK0s

SDカードからカーネルを起動する際の流れについて説明。

# ブートの流れ
* ROMコード  
CPUに埋め込まれている。ピン設定を元にブートデバイスを特定。1stステージブートローダを探し、SoC内のSRAMに展開
* 1stステージブートローダ  
DRAM, NAND、MMCコントローラを初期化。2ndステージブートローダをDRAMに展開し、実行。
* 2ndステージブートローダ  
kernelやdtbをRAMに展開し、kernelに処理を渡す
  
https://wiki.tizen.org/images/b/bd/Lecture-1.pdf

## ROMコード

### アーキテクチャ
ROMコードのアーキテクチャは以下のとおり。

* ハイレベルレイヤ  
ROMコードのメインタスクであり、watchdog timer やクロックの設定、ブートルーチンが含まれる。

* ドライバレイヤ  
各デバイスと通信するためのプロトコル実装

* HAL 
実際のペリフェラルを制御するための低レベルなコード

つまり・・・  
ROM Codeにはブートに必要なプログラムとして、メインルーチンの他、FATやらXMODEやらTFTPやらが含まれており、
それらは、ドライバが提供する通信プロトコル（UART、SPI、USBなどなど）を使用する。
それぞれのドライバがIPの操作を行う場合は、HALが提供するAPIを使う。  
・・・ということだと思う。


### 初期化
ROMコードはCPUに埋め込まれているため、完全にCPU依存。
ROMコードは1st BLをSRAMに展開する。

プロセッサのリセットが走ると、ROMの先頭に処理が移り、ROMコードが実行される。
* システムの初期化
* スタックのセット
* Watchdog Timerのセット（3分）
* クロックの設定
* SYSBOOTピンの設定を元に、ブートデバイスを特定し、イメージを見つけ、ロードする 
    * 見つかる前にwatchdog timerが切れると、システム全体がリセットされる。
    * ブートデバイブートの方法には、２つあり、これらは、SYSBOOTピンなどの設定によって、SoCに伝えることができる。
    ROMコードは、この設定を元に、ブートデバイスを特定する。
        * メモリブート  
        フラッシュメモリなどの記憶媒体から、初期化コード起動する。cold/warm reset 後に行われる。  
        *  ペリフェラルブート  
        UART、USB、Ethernetなどを使い、実行コードを持ってくる方式。デバイスをフラッシュする場合などに使う。
        

### 1st BLをMMC/SDカードからブート
* MMC/SDのドライバを初期化
* カード内にある1st BLが、rawモードか、ブートファイルかを特定する  
    * rawモード  
    #0か#1024のセクタにあり、その先頭に、Configuration Header（CH）が置かれている必要がある。
    ddコマンドで、1st BL, 2nd BLを配置するのが簡単。
    * FATモード
    FATでフォーマットされたプライマリパーティションのルートディレクトリに置かれたイメージをロード　
    
## 1st BL
DRAM, NAND、MMCコントローラを初期化。
ストレージ（NANDフラッシュ、SPIフラッシュ、NORフラッシュ、eMMCなど）から2nd BLをRAMにロードし、実行。
通常、ストレージIPのドライバは、1st BLに含まれてる。
（そうしないと、MMCとかにアクセスできないもんな・・・）

### 1st BLはなぜ必要か？
* ROM codeから、直接u-bootをSOCのSRAMに展開、実行してはいけないのか？  
SOC内部のSRAMは高価で、128kb程度しか無い。
u-bootは多機能で、それに比べてサイズが大きいので、u-bootをDRAMに展開する1stBLが必要。

* ROM Codeが、u-bootを直接DRAMに展開すれば良いのではないか？  
DRAM（SoC内ではなくボード上に存在）を使うには、まず初期化する必要がある。
しかしROM Codeが起動した時点では、SoCは、外部にどんなデバイスが接続されているか知らないため、初期化もできない。
そのため、ボード専用の1st BLが、DRAMを初期化し、2nd BLをDRAMに展開する。
    
### ポーティング手順
* 1st BLからRAMに関する設定を見つける  
    * これをやらないと、RAMに2nd BLを展開できない
* ストレージIPを設定する
    * これをやらないと、ストレージから2nd BLを持ってこれない
* RAMに2nd BLをコピーする処理を書く

なお、ストレージIPのドライバは、1st BLに含まれている。

## 2nd BL
大抵、u-bootが使われる。
ストレージからRAMにLinuxカーネルやinitramfsをロード。
必要に応じてDevice TreeやATAGをロード。

### ポーティング手順
* ストレージIPを設定する
    * こうしないとカーネルなどをストレージから取得できない
    * 1st BLの設定は引き継げないのだろうか？？？
* LinuxカーネルをRAMに展開する処理を書く
* （オプション）Device TreeをRAMに展開する処理を書く
* （オプション）ブートスクリプトを書く
* （オプション）

### デバイスタイプ
ROM Codeにおいて、デバイスには２種類ある。
セキュアブートかどうかに関係しており、イメージのフォーマットも変わってくる。

* high secure device(HS)  
認証されてない実行コードは許可しない。

* general-purpose device(GP)  
実行コードに対する認証を行わない


# 補足
## HALとデバイスドライバの違い
* HAL  
プロセッサの違いを吸収するためのレイヤ。
レジスタ、タイマ、DMA、割り込みなど、プロセッサごとの機能へのアクセスを抽象化する。
ドライバはHALに処理を依頼し、HALは、プロセッサに応じた処理を行う。
https://sciencepark.co.jp/device_driver/dvdr/report-8/

とはいえ、[ここ](https://stackoverflow.com/questions/13577660/define-hal-above-or-below-driver-layer)を見ると、ドライバの上にHALを置く場合もあるようだ。


