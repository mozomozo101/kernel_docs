# メモリ管理
メモリの管理は、カーネルのメモリ管理機構の役割。
実際は10部屋しか無いホテルを、あたかも200部屋もあるように見せようとてんやわんやしてる奴。

* 物理アドレス空間
  * 実際のメモリの配置そのもの。
  * 64MBのメモリ搭載なら、物理アドレス空間の広さは64MB
* 仮想アドレス空間
  * カーネルは、指定できる最大サイズまでメモリを使用できると仮定して動作する。
  * 32bitOSなら、2^32=4GB

ちなみに、仮想アドレス空間より大きいサイズのメモリを使う場合は、HIGHMEMという仕組みを使うらしい。

# 仮想アドレス空間の構造
メモリ管理機構は、4GBの仮想アドレス空間を、このように区別する。
* 上位3GBはユーザ空間用 (0x00000000 ~ 0xBFFFFFFF)
* 下位1GBはカーネル空間用 (0xC0000000 ~ 0xFFFFFFFF)

カーネル内のプログラム（スケジューラ、ファイルシステム等）は、基本的に仮想メモリを使う（デバイスアクセスに物理アドレスを使うこともあるが）。
ただ、仮想メモリから物理メモリへの変換はかなりコストが掛かる。
それを極力抑えるため、カーネル空間では、仮想アドレスと物理アドレスは、1対1対応させている。

# ユーザプロセスごとのメモリ空間
カーネルは、ユーザプロセスに対して、それぞれに 3GBの 仮想メモリ空間を割り当てる。
もちろん、実際には別々の物理アドレスが対応している。
このため、各プロセスは、3GBのメモリ空間を、他のプロセスを気にせず、自由に使うことができる。
この時、カーネルは、プロセスが要求してくる仮想アドレスと物理アドレスの対応を管理する必要がある。
これを実現するための仕組みが、「仮想記憶」。

# 仮想記憶と物理アドレスの割り当て
仮想アドレスと物理アドレスを1番地ずつ対応付けるのは効率が悪い。
そこでカーネルは、物理/仮想アドレス空間を、固定長ブロック単位（一般的に4KB）で管理する。
仮想アドレスのブロックは「ページ」、物理アドレスのブロックは「フレーム」と呼ぶ。
で、カーネルは、このページとフレームの対応を、「ページテーブル」に保持する。
ページテーブルは、RAM上に展開されている。
ちなみに、ページテーブルの中に書かれている対応付け１つ１つを、「ページテーブルエントリー（PTE）」と呼ぶ。

## MMU： Memory Management Unit
ページテーブルはRAM上に展開されているため、アクセスに時間がかかる。
そのため、大抵のアーキテクチャには、ページテーブルを処理するための専用ハードウェアMMUがある。
これなら、RAMへのアクセスは不要だし、ページテーブルの処理にCPU時間を消費しなくて済むので、高速になる。

## TLB: Translation Lookaside Buffer
実は、MMUの後ろには、更に高速な処理を実現できる、TLBが搭載されている。
ただ、TLBは、保持できるマッピングの数に限りがある（4096程度）。
そこで、MMUを使いつつTLBを最大限に活用するため、以下の流れでフレームを検索する。

**例：ユーザプロセスが、仮想アドレス 0xD09FBABE へのアクセスを要求した場合**

このアドレスは、2つに分けられる
* 上位20bit（0xD09FB）
  * ページ番号
* 下位12bit（0xABE）
  * ページの先頭からのオフセット値
  * 物理メモリのブロック（フレーム）の先頭からのオフセット値

で、以下の流れで検索する。
* ページ番号 0xD09FB をTLBで検索
  * ヒットしたら、そこから物理アドレスを取り出し、オフセット値を加算して、目的の物理アドレスを得る
* ヒットしなかったら、MMUでページテーブルを検索する
  * ヒットしたら、TLBの時と同じようにして、目的の物理アドレスを得る
* ページテーブルにも無かったらページフォルト発生
  * あり得るパターン（ここでは深く触れない）
    * スワップ済みのデータ
    * 不正なページへのアクセス
物理メモリに空きがない












